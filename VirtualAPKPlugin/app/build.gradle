apply plugin: 'com.android.application'
apply plugin: 'com.didi.virtualapk.plugin'

android {
    compileSdkVersion 28
    defaultConfig {
        applicationId "com.android.virtualapk.plugin"
        minSdkVersion 21
        targetSdkVersion 28
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }

    signingConfigs{
        release{
            storeFile file('../../apkSignvirtualApk.jks')
            storePassword "123456"
            keyAlias "virtual"
            keyPassword "123456"
        }
    }

    android.applicationVariants.all {
        variant ->
            variant.outputs.all {
                // 此处指定生成的apk文件名
                outputFileName = "VirtualAPKPlugin.apk"
            }
    }

    buildTypes {
        release {
            minifyEnabled false
            signingConfig signingConfigs.release
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation 'com.android.support:appcompat-v7:28.+'
    implementation 'com.android.support.constraint:constraint-layout:1.0.2'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.1'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'
}

virtualApk{
    // packageId用于定义每个插件的资源id，多个插件间的资源Id前缀要不同，避免资源合并时产生冲突
    packageId = 0x6f
    // targetHost指明宿主工程的应用模块，插件编译时需要获取宿主的一些信息，比如mapping文件、依赖的SDK版本信息、R资源文件，一定不能填错，否则在编译插件时会提示找不到宿主工程。
    targetHost = '../../VirtualAPKHost/app'
    // applyHostMapping表示插件是否开启apply mapping功能。当宿主开启混淆时，一般情况下插件就要开启applyHostMapping功能。因为宿主混淆后函数名可能有fun()变为a()，插件使用宿主混淆后的mapping映射来编译插件包，这样插件调用fun()时实际调用的是a()，才能找到正确的函数调用。
    applyHostMapping = true
}
